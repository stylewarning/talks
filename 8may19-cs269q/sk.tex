\section{The Strong Compilation Problem}
Relatively straightforwardly, we can encode the problem of compilation in the language of mathematics of unitary operators. The usual compilation problem goes something like this:
\begin{problem}[The Strong Compilation Problem]\label{prob:strongcomp}
Let $G$ be a discrete and finite subset of $SU(2^n)$ and let $U\in SU(2^n)$. Given a fixed but arbitrary $\epsilon > 0$, find a finite sequence of $\ell$ elements of $G$ \[V := g_\ell\cdots g_2g_1\] such that \[\max_{\ket{\psi}}\Vert (U - V)\ket{\psi}\Vert < \epsilon.\]
\end{problem}
This problem is called ``strong'' because it must account for maximum error across \emph{all} possible states. It turns out that Solovay and Kitaev determined that it is efficiently solvable, provided that the group generated by $G$ is dense in $SU(2^n)$ and that if $g\in G$, then $g^{\dagger}\in G$ too.
\begin{theorem}[Solovay--Kitaev\cite{skalg}]
The Strong Compilation Problem can be solved with sequences of length $\ell\in O([\log(1/\epsilon)]^c)$ where $c > 3$ in time complexity\footnote{These complexities are known as \emph{polylog}, because they are polynomials of logarithms.} $O([\log(1/\epsilon)]^c)$ where $c > 2$.
\end{theorem}
They proved this theorem constructively, meaning that the actual sequence of gates to reconstruct $U$ is computed. That method is called the \emph{Solovay--Kitaev algorithm}, and---in the grand scheme of all things quantum---is quite simple.

This theorem should be understood appropriately because it has a hidden but nonetheless crucial detail. In the problem and the theorem, the value of $n$---the number of qubits---is fixed. That is to say, it makes a statement about the length of approximating $n$-qubit operators with a set of $1$- to $n$-qubit operators. If $n$ is \emph{not} fixed, then the complexity becomes $O(2^n[\log(1/\epsilon)]^c)$. In general, this is to be expected. The size of Hilbert space grows exponentially with the number of qubits, so approximating many-qubit operators with few-qubit operators requires an exponential number of them, and then some to accommodate our bound on errors.

With that caveat in mind, this is a landmark theoretical result, as it shows that the compilation problem is tractable on a classical computer. However, the Strong Compilation Problem and Solovay--Kitaev find most of their popularity in quantum error correction circles. A huge benefit of the Solovay--Kitaev algorithm is that it only needs a finite set of gates. This is beneficial in the study of quantum error correction because one can devise schemes to error-correct exactly the gates in the gate set.

Solovay--Kitaev is more foreign to the scientists and engineers of NISQ\footnote{``Near-term Intermediate Scale Quantum''} devices, however, because Solovay--Kitaev doesn't take into account the facilities and detriments of a NISQ system. On the plus side, many NISQ systems have continuous families of gates available to them, such as \PauliZ{}-rotations, with virtually perfect fidelity. On the minus side, NISQ devices and the associated gates have noise, and the compilation procedure doesn't take any of that into account. As such, we file Solovay--Kitaev away as an important theorem that provides a bright glimmer of hope for the aspiring quantum compiler developer.

From here, we will focus on understanding compilation that is perhaps more appropriate for NISQ devices, and to do this, we will want the machinery of the QAM.